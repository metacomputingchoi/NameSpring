package com.ssc.namespring.study

class Day5 {
    // 지난주 안해온 숙제 기억나는 거
    // 1. 과도한 설계 지양(if-else, file수많은거, 과도한?패턴?? 이런거 때문에 프로젝트가 계속 진행되면서 걷잡을 수 없는 쪽으로 가게 됨)
    // - 껍데기만 있는 빈 클래스 코드는 그냥 과감하게 제거하세요.
    // 2. exception 고도화 해보기 (optional)
    // 3. 데이터 클래스 중복될만한거 간소화하기(여러 데이터클래스가 비슷비슷한 멤버변수 여러번 등장시키지마라. 이런 클래스들 많아지면 오용하게된다 -> 공감하면서 코드 동작되도록 바꿔오께)
    // - source?? 형왈: 이 클래스는 input넣을때 쓰는 건데, 내가 잘못써서 input 넣은 클래스의 멤버변수 안에 있는 값을 써서는 안되는 흐름에서 씀. 바꿔오께
    // - 상속으로 오버라이딩 후 result 값 멤버변수를 추가해서 사용하는 코드 썼음. 컴파일단에서 개발자의 실수를 미리 알아챌 수 있도록 기교 부렸었고, 그 코드 쓸수있게 바꿔오기로 함

    // 이번주 숙제 : 엎은 코드에서도 또 배울게 있나 리뷰하고 숙제만들기
    // - 스스로 코드 짜면서 답답했던 부분 답안지 줌
    // - 바꿔보기
    // 1) 전체적인 소스코드파일들의 배치 구조 (프로젝트 구조) 를 좀 더 최적화할 수 있는 부분이 있을까?
    //  -- data class 들은 모두 각자의 파일로 관리하는 게 좋은가..., 또는 private으로 특정 클래스에서만 쓰거나 그러면 그냥 거기 남겨둘까...
    //      -> 상황에 따라 다름. inner class의 경우에도 inner static/non-static class로 구분할지 또한 고민할 수 있음.
    //      해당 class의 캡슐화를 할지 말지에 대한 철학에 따라 달라짐. 숨기고싶다? = inner class

    //  -- constants 도 지금 300줄 넘어가는데... 그런데 이걸 여러 파일로 나누자니 또 너무 불필요하게 파일이 8개 이렇게 늘어나는데... 그게 맞나?
    //      -> constants들도 카테고라이징이 안되어 있어서 발생하는 문제. constants가 일부 카테고라이징 되어야 하고
    //      분류나 특성이 클러스터화된다면, 그 클러스터에 맞는 이름을 부여한 constants로 쪼개야 함. ex. Android Activity, Context, View, .. 등 예시 참고

    //  -- 비슷한 목적을 가진 data class나 constant든 뭐든 그런 애들은 너무 불필요하게(??? 불필요한지도 모름)?? 개별 파일 단위로 다 나눠주는 게 맞나? 어떤 기준으로 이걸 적절히 끊어주는 게 맞나?
    //      -> "개별로 쪼개"야 함. 그러나 이또한 공통적인 특성들의 집합으로 묶을 수 있는데, 이 경우 패키지로 파일들을 묶음. 결국 hierarchical 구조가 됨. 그게 "패키지"의 핵심 기능
    //      질문: "어떤 기준"으로 "적절히" 끊을것인가? 가 바로 개발자가 늘 고민해야하는 부분이 맞고 완벽한 정답은 없음. 다만, "어떤 기준"은 누가봐도 기준이 합리적이면 그게 정답이라고 보는게 맞음

    //  -- 나중에 지금 각 이름 생성마다 얻어진 분석한 데이터들(결과 + 근거)을 토대로, 2차/3차 비지니스 로직들(보고서 생성 등)을 만들게 될텐데... 그런것들도 모두 model로 들어가나? 아니면 그 상위 계층으로 가는가?
    //      -> model

    //  -- 그리고, 지금 ./model/ 경로 아래에서만 지금 내 프로젝트 파일들을 모두 관리하고 다루고 있는데, 실제로 더 최적화되어도 model 스코프 안에서만 모두 존재하게 될 것인가?
    //      -> 비 model 코드를 아직 시작도 못했음. 그래서 model에만 있음. 프로젝트 코드의 패키지 분류도 M, V, C로 나뉜다고 보면 됨.

    //  -- Logger 같은 경우, 잠깐 든 생각은 안드로이드에서 사용하는 Log.d 같은 것들이 만약 다른 운영체제에서 사용하게 되면 인터페이스 잡아서 운영체제별로 로거 따로 정의해주는 형태로 가는 게 실제로 현업에서 하는 건지... 그냥 든 생각.
    //      -> 사실 이상적으로는 println을 model에서만 써도 됨. 다만, 앱을 짜면서 만든 코틀린 코드를 외부 환경에서도 공용으로 사용하고자 한다면 println wrapper를 씀.
    //      -> 이 부분에 대해서는 "추상화 레이어"라는걸 도입한 외부 라이브러리들의 설계가 도움이 됨. 예제는 코드로 별도 설명 필요함(OpenGL로 따지면 EGL임)

    // (로직 코틀린으로 짜기: due:06.26일 )
}